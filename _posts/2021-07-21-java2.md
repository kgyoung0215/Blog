---
layout: post
title: "JAVA 1차 정리"
subtitle: "배열/클래스/메소드/캡슐화등"
date: 2021-07-21 21:00:00 +0900
#background: '/img/posts/01.jpg'
categories: ['JAVA']
---
___

### 끄적끄적 한번 더 타이핑 하면서 회상?

1. 자바특징 - Write Once, Run Anywhere은 플랫폼의 제약을 받지않음을 설명.

- .cpp -> compile -> Machine code -> 운영체제 종속적
- .JAVA -> compile -> class(바이트코드) ->JVM(window/Linux/mac)

1. 자바는 GC가 힙영역의 참조하지않은 메모리를 정리하는 역할을 한다.

2-1. 그럼 GC는 언제 발생하는가 ? 정확히는 알 수 없다.

1. 일단 스크립트(notepad/++등) 보다 IDE(이클립스,인텔리제이)를 쓰는 이유 ?

: 사람이기에 발생하는 실수가 줄어들고 개발 생산성이 향상되기 때문이다.

1. 워크스페이스 변경법 : file -> switch workspace ^^

1. 한글인코딩 -> preference -> encoding 검색 -> [MS949 -> UTF-8]

: eclipse.ini 에 -Dfile.encoding = UTF-8 추가. default 값으로 변경

1. variable란? 변수이며, 기본형/ 참조형으로 나뉨

- 기본형 : byte char short int long float double boolean 총 8가지
- 참조형 : 그외 모든 것

1. ASCII 값 'A' = 65 , 'a' = 97

8. 묵시적 형변환이 가능한 경우

: byte -> short -> int -> long -> float -> double

자료의 손실의 걱정이 없으며, JVM이 처리해주는 것임.

long(64bit), float(32bit)이지만 부동소수점 때문에 묵시적형변환 가능.

9. 명시적 형변환을 해야하는 이유? 

:값 손실이 발생할수 있으므로 프로그래머 책임하에 형변환 하는 것!

10. 모든 연산자는 비교 시, 양쪽의 데이터 Type부터 확인하며
묵시적 형변환이 불가한 경우, 에러가 발생함.

11. 정수 -> 오버플로우 조심, 실수 -> 값의 부정확함을 조심해야함.

12. 시프트 연산자 <<는 *2ⁿ >>는 /2ⁿ 일반적인 *, / 보다 빠르다.

이유? * 를 할경우 컴퓨터가 시프트연산을 하기 때문

13. Math.Random 보다는 Random 클래스를 사용하는 추세!

14. 반복문의 break/continue위치를 지정이 필요 한 경우 label을 사용한다.

15. int는 기본형 변수이나 int형 '배열'은 참조형 변수이다.

: 배열은 생성과 동시에 초기화가 이루어져야한다.

16. 자바도 파이썬의 foreach와 같은 구문이 존재한다 . 

: ex. for(int item : items)

17. Arrays.toString(arr) 1차원 배열의 디버깅용도로 자주쓰인다 

18. Arrays.deeptoString(arr) 2차원 배월의 디버깅용도로 쓰인다.

19. ** 배열은 연속공간에 할당받기 때문에 순차적인 자료구조에 강하고 빠르다.

20. 객체지향의 목적은 유지보수성!

21. 현실에 존재하는 객체 -> 클래스화 -> 프로그래밍의 객체로(인스턴스/오브젝트)

: ex. 사람의 종류(?)는 어떻게 나눌수 있을까 ? -> 구체화 -> 타입생성

22. static(상수풀, global)처럼 import 혹은 접근시 이미 메모리에 적재하는 친구들

23. stack 메서드영역 ! 음 객체?, 멤버변수 등!

24. heap 객체를 저장하기 위한 영역공간. (GC가 관리하는 영역)

25. 인스턴스란!!!! heap영역에 올라간 객체를 가리킨다.

26. 파일입력 받는 법. System.setIn(new FileInputStream("경로"))

-> 예외 처리에 대한 이셉션 처리 경고문이 뜬다.

-> main 클래스에 throws Exception 추가. JVM(시스템)이 처리할 것이라는 의미

27. 객체(object) = Instance와 같은 말이다.

28. 클래스(class) 객체에 = null 의미 . 초기화를 했지만 주소할당은 아직 안한 것.

29. 프로그래밍에 있어 널포인터참조와 아웃오브바운드는 발생하면 안된다. 조심!

30. this. 키워드 해당 클래스 내부 접근자

31. 단축키 정리도 한번해야겠다.

32. CallByReference = 주소 공유

33. CallByReference = 값 전달

34. 위에 작성한 static의 이유로 클래스를 static으로 선어하면 new를 안해도 바로 접근할 수 있음.

: 이미 메모리에 로딩되어 있기 때문

: 다만, heap영역이 아니기 때무네 this, super 키워드 사용불가함.(heap)에서만 사용가능.

35. 메서드 오버로딩. 클래스 내에서 같은 함수명이지만 매개변수나 리턴타입을 달리하여 사용하는 것.

cf) 마지막 인자에 int ... a 등으로 설정하면 [] 갯수에따른 배열처리를 자동으로 처리해줌.

36. ** 접근제한자가 없으면 같은 패키지에서 사용가능! (import 필수)

37. ** public 같은 프로젝트 안에서 '누구나' 사용 가능!

38. ** private은 class 내에서만 사용 가능!!

39. 캡슐화 ? get set을 쓰는 이유. 멤버변수를 private 하는 이유임. 보안

40. 생성자함수가 생성자함수를 참조 할 경우 맨 첫줄 this( , , )을 이용하여 사용 가능

: 인자 있는 생성자 함수 사용 시, default 생성자 필수 생성 필요.

41. 키워드 _ 멤버란? (클래스 내부) , 지역(함수 내부)

일단 여기까지!!!
